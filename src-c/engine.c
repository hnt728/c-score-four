#include "engine.h"

#include <stdbool.h>
#include <string.h>
#include <limits.h>

static const uint64_t k_top_bit = UINT64_C(0x8000000000000000);
static const uint64_t k_first_floor = UINT64_C(0xFFFF000000000000);

static const uint64_t conditions[76] = {
    0b1111000000000000000000000000000000000000000000000000000000000000,
    0b0000111100000000000000000000000000000000000000000000000000000000,
    0b0000000011110000000000000000000000000000000000000000000000000000,
    0b0000000000001111000000000000000000000000000000000000000000000000,
    0b0000000000000000111100000000000000000000000000000000000000000000,
    0b0000000000000000000011110000000000000000000000000000000000000000,
    0b0000000000000000000000001111000000000000000000000000000000000000,
    0b0000000000000000000000000000111100000000000000000000000000000000,
    0b0000000000000000000000000000000011110000000000000000000000000000,
    0b0000000000000000000000000000000000001111000000000000000000000000,
    0b0000000000000000000000000000000000000000111100000000000000000000,
    0b0000000000000000000000000000000000000000000011110000000000000000,
    0b0000000000000000000000000000000000000000000000001111000000000000,
    0b0000000000000000000000000000000000000000000000000000111100000000,
    0b0000000000000000000000000000000000000000000000000000000011110000,
    0b0000000000000000000000000000000000000000000000000000000000001111,
    0b1000100010001000000000000000000000000000000000000000000000000000,
    0b0100010001000100000000000000000000000000000000000000000000000000,
    0b0010001000100010000000000000000000000000000000000000000000000000,
    0b0001000100010001000000000000000000000000000000000000000000000000,
    0b0000000000000000100010001000100000000000000000000000000000000000,
    0b0000000000000000010001000100010000000000000000000000000000000000,
    0b0000000000000000001000100010001000000000000000000000000000000000,
    0b0000000000000000000100010001000100000000000000000000000000000000,
    0b0000000000000000000000000000000010001000100010000000000000000000,
    0b0000000000000000000000000000000001000100010001000000000000000000,
    0b0000000000000000000000000000000000100010001000100000000000000000,
    0b0000000000000000000000000000000000010001000100010000000000000000,
    0b0000000000000000000000000000000000000000000000001000100010001000,
    0b0000000000000000000000000000000000000000000000000100010001000100,
    0b0000000000000000000000000000000000000000000000000010001000100010,
    0b0000000000000000000000000000000000000000000000000001000100010001,
    0b1000000000000000100000000000000010000000000000001000000000000000,
    0b0100000000000000010000000000000001000000000000000100000000000000,
    0b0010000000000000001000000000000000100000000000000010000000000000,
    0b0001000000000000000100000000000000010000000000000001000000000000,
    0b0000100000000000000010000000000000001000000000000000100000000000,
    0b0000010000000000000001000000000000000100000000000000010000000000,
    0b0000001000000000000000100000000000000010000000000000001000000000,
    0b0000000100000000000000010000000000000001000000000000000100000000,
    0b0000000010000000000000001000000000000000100000000000000010000000,
    0b0000000001000000000000000100000000000000010000000000000001000000,
    0b0000000000100000000000000010000000000000001000000000000000100000,
    0b0000000000010000000000000001000000000000000100000000000000010000,
    0b0000000000001000000000000000100000000000000010000000000000001000,
    0b0000000000000100000000000000010000000000000001000000000000000100,
    0b0000000000000010000000000000001000000000000000100000000000000010,
    0b0000000000000001000000000000000100000000000000010000000000000001,
    0b1000010000100001000000000000000000000000000000000000000000000000,
    0b0000000000000000100001000010000100000000000000000000000000000000,
    0b0000000000000000000000000000000010000100001000010000000000000000,
    0b0000000000000000000000000000000000000000000000001000010000100001,
    0b0001001001001000000000000000000000000000000000000000000000000000,
    0b0000000000000000000100100100100000000000000000000000000000000000,
    0b0000000000000000000000000000000000010010010010000000000000000000,
    0b0000000000000000000000000000000000000000000000000001001001001000,
    0b0001000000000000001000000000000001000000000000001000000000000000,
    0b0000000100000000000000100000000000000100000000000000100000000000,
    0b0000000000010000000000000010000000000000010000000000000010000000,
    0b0000000000000001000000000000001000000000000001000000000000001000,
    0b1000000000000000010000000000000000100000000000000001000000000000,
    0b0000100000000000000001000000000000000010000000000000000100000000,
    0b0000000010000000000000000100000000000000000100000000000000010000,
    0b0000000000001000000000000000010000000000000000010000000000000001,
    0b1000000000000000000010000000000000000000100000000000000000001000,
    0b0100000000000000000001000000000000000000010000000000000000000100,
    0b0010000000000000000000100000000000000000001000000000000000000010,
    0b0001000000000000000000010000000000000000000100000000000000000001,
    0b0000000000001000000000001000000000001000000000001000000000000000,
    0b0000000000000100000000000100000000000100000000000100000000000000,
    0b0000000000000010000000000010000000000010000000000010000000000000,
    0b0000000000000001000000000001000000000001000000000001000000000000,
    0b0000000000000001000000000010000000000100000000001000000000000000,
    0b1000000000000000000001000000000000000000001000000000000000000001,
    0b0001000000000000000000100000000000000000100000000000000000001000,
    0b0000000000001000000000000100000000000010000000000001000000000000
};

#define MAX_CELL_LINES 16
static uint8_t g_cell_lines_count[64];
static uint64_t g_cell_lines[64][MAX_CELL_LINES];
static bool g_inited = false;

static void init_cell_lines(void) {
    memset(g_cell_lines_count, 0, sizeof(g_cell_lines_count));
    for (int li = 0; li < 76; li++) {
        const uint64_t mask = conditions[li];
        for (int idx = 0; idx < 64; idx++) {
            const uint64_t bit = (uint64_t)k_top_bit >> idx;
            if ((mask & bit) == 0) continue;
            uint8_t n = g_cell_lines_count[idx];
            if (n < MAX_CELL_LINES) {
                g_cell_lines[idx][n] = mask;
                g_cell_lines_count[idx] = (uint8_t)(n + 1);
            }
        }
    }
    g_inited = true;
}

static inline int bit_to_index(uint64_t bit) {
    if (bit == 0) return -1;
#if ULONG_MAX == 0xffffffffffffffffUL
    return (int)__builtin_clzll(bit);
#else
    int x = 0;
    uint64_t msb = UINT64_C(1) << ((int)(sizeof(uint64_t) * 8) - 1);
    while ((bit & msb) == 0) {
        bit <<= 1;
        x++;
    }
    return x;
#endif
}

static inline uint64_t index_to_bit(int index) {
    if (index < 0 || index >= 64) return 0;
    return (uint64_t)k_top_bit >> (unsigned)index;
}

static inline uint64_t get_possible_pos_board(uint64_t black_board, uint64_t white_board) {
    uint64_t board = black_board | white_board;
    return ((board >> 16) ^ board) ^ k_first_floor;
}

static inline int get_possible_poses_binary(uint64_t black_board, uint64_t white_board,
                                            uint64_t array[16]) {
    uint64_t board = k_top_bit;
    uint64_t possible_pos_board = get_possible_pos_board(black_board, white_board);
    int array_index = 0;
    for (int i = 0; i < 64; i++) {
        if ((possible_pos_board & (board >> i)) != 0) {
            array[array_index] = board >> i;
            array_index++;
        }
    }
    return array_index;
}

static inline char which_is_win(uint64_t black_board, uint64_t white_board) {
    for (int i = 0; i < 76; i++) {
            const uint64_t cond = conditions[i];
        if ((black_board & cond) == cond) {
            return 'b';
        } else if ((white_board & cond) == cond) {
            return 'w';
        }
    }
    if (get_possible_pos_board(black_board, white_board) == 0) {
        return 'd';
    }
    return 'n';
}

void az_init(void) {
    if (!g_inited) {
        init_cell_lines();
    }
}

int az_legal_moves(uint64_t black, uint64_t white, uint64_t out_moves[16]) {
    return get_possible_poses_binary(black, white, out_moves);
}

char az_result(uint64_t black, uint64_t white) {
    return which_is_win(black, white);
}

void az_apply_move(uint64_t black, uint64_t white, char turn, uint64_t move,
                   uint64_t *out_black, uint64_t *out_white) {
    uint64_t nb = black;
    uint64_t nw = white;
    if (turn == 'b') {
        nb |= move;
    } else if (turn == 'w') {
        nw |= move;
    }
    if (out_black) *out_black = nb;
    if (out_white) *out_white = nw;
}

int az_move_index(uint64_t move) {
    return bit_to_index(move);
}

uint64_t az_move_bit(int index) {
    return index_to_bit(index);
}
